# JavaScript中的异步

异步所关注的核心点就是现在运行的部分与未来运行的部分之间的关系。

## 1. 事件循环

JavaScript 引擎是依托宿主环境运行的。宿主环境可以是 Web浏览器、也可以是服务器等。

这些环境还提供了一种机制，用以在适当的时候调用 JS 引擎来执行代码块。这种机制就是事件循环。

在 ES6 之后，事件循环纳入了 JS 引擎的势力范围。主要是因为 Promise 可以精细的控制事件循环队列。

我们模拟一个事件循环，虽然不准确，可以加深理解。

```
var eventLoop = []; // 先进先出队列
var event;

while( true ){
    if( eventLoop.length > 0 ){
        event = eventLoop.shift();
    }

    try{
        event();
    }catch( err ){
        console.log( err );
    }
}
```

这一段简洁的有些粗暴的代码不能够说明事件循环具体的机制，只能说明概念。

比如 setTimeout(...,0) 之类的代码并不是直接把回调放进了事件循环排队执行。而是放进了 Marco Tasks 中。与之相对的是 Micro Tasks。这个后边会说。

## 2. 并行线程

异步执行指的是现在执行和未来执行的关系，并行强调的是同时执行。二者不能混为一谈。

并行最常见的工具就是线程和进程，多个线程共享一个进程。事件循环是事件队列排队执行，不允许对共享内存的并行访问和修改。

并行是语句级别的交替执行，而JS是单线程的，其代码执行具有原子性。二者粒度不同。

```
var a = 20;

function foo(){
    a = a + 1;
}

function bar(){
    a = a * 2;
}

Ajax('someurl', foo);
Ajax('someurl', bar);
```

所谓原子性，就是指上面代码中 foo 执行和 bar 执行是完整执行的。也就是说， foo 执行的时候不会被 bar 中断， bar 执行的时候不会被 foo 中断。二者谁先执行，需要竞争，而且输出的结果是不一样的。这就是竞态条件。

假如JS可以多线程并行执行上面的代码，这样的并行是语句级别的，其结果和过程更加的复杂。需要我们外加条件，比如同步锁机制来限制并行的访问和操作内存。
